package sshconfig

import (
	"os"
	"path/filepath"
	"strings"
	"testing"

	"github.com/stretchr/testify/require"

	model "github.com/grafviktor/goto/internal/model/host"
	"github.com/grafviktor/goto/internal/testutils/mocklogger"
)

func TestWriter_WriteToFile(t *testing.T) {
	// Create test hosts
	hosts := []model.Host{
		{
			ID:               1,
			Title:            "server1",
			Address:          "192.168.1.100",
			LoginName:        "admin",
			RemotePort:       "22",
			IdentityFilePath: "~/.ssh/id_rsa",
			Group:            "production",
			Description:      "Production server 1",
		},
		{
			ID:          2,
			Title:       "server2",
			Address:     "example.com",
			LoginName:   "user",
			RemotePort:  "2222",
			Group:       "development",
			Description: "Development server",
		},
		{
			ID:      3,
			Title:   "server3",
			Address: "test.example.com",
			Group:   "test",
		},
	}

	// Create temporary directory and file
	tmpDir, err := os.MkdirTemp("", "ssh_config_test")
	require.NoError(t, err)
	defer os.RemoveAll(tmpDir)

	filePath := filepath.Join(tmpDir, "hosts.config")

	// Create writer and write config
	logger := &mocklogger.Logger{}
	writer := NewWriter(filePath, logger)

	err = writer.WriteToFile(hosts)
	require.NoError(t, err)

	// Read and verify the generated config
	content, err := os.ReadFile(filePath)
	require.NoError(t, err)

	configStr := string(content)

	// Verify server1 configuration
	require.Contains(t, configStr, "Host server1")
	require.Contains(t, configStr, "    # GG:GROUP production")
	require.Contains(t, configStr, "    # GG:DESCRIPTION Production server 1")
	require.Contains(t, configStr, "    HostName 192.168.1.100")
	require.Contains(t, configStr, "    User admin")
	require.Contains(t, configStr, "    IdentityFile ~/.ssh/id_rsa")

	// Verify server2 configuration (custom port)
	require.Contains(t, configStr, "Host server2")
	require.Contains(t, configStr, "    # GG:GROUP development")
	require.Contains(t, configStr, "    # GG:DESCRIPTION Development server")
	require.Contains(t, configStr, "    HostName example.com")
	require.Contains(t, configStr, "    User user")
	require.Contains(t, configStr, "    Port 2222")

	// Verify server3 configuration (minimal)
	require.Contains(t, configStr, "Host server3")
	require.Contains(t, configStr, "    # GG:GROUP test")
	require.Contains(t, configStr, "    HostName test.example.com")

	// Verify default port (22) is not included for server1
	server1Block := extractHostBlock(configStr, "server1")
	require.NotContains(t, server1Block, "Port 22")

	// Verify proper spacing between hosts
	hostCount := strings.Count(configStr, "Host ")
	require.Equal(t, 3, hostCount)
}

func TestWriter_generateSSHConfig(t *testing.T) {
	hosts := []model.Host{
		{
			ID:      1,
			Title:   "testhost",
			Address: "test.com",
		},
	}

	logger := &mocklogger.Logger{}
	writer := NewWriter("test.config", logger)

	config := writer.generateSSHConfig(hosts)

	require.Contains(t, config, "# Generated by goto application")
	require.Contains(t, config, "Host testhost")
	require.Contains(t, config, "    HostName test.com")
}

func TestWriter_writeHostEntry_EmptyTitle(t *testing.T) {
	host := model.Host{
		ID:      1,
		Title:   "", // Empty title
		Address: "test.com",
	}

	logger := &mocklogger.Logger{}
	writer := NewWriter("test.config", logger)

	var sb strings.Builder
	writer.writeHostEntry(&sb, host)

	// Should not write anything for empty title
	require.Empty(t, sb.String())
}

func TestWriter_writeHostEntry_UserDefinedSSHCommand(t *testing.T) {
	host := model.Host{
		ID:      1,
		Title:   "testhost",
		Address: "user@example.com -p 2222", // User-defined SSH command
	}

	logger := &mocklogger.Logger{}
	writer := NewWriter("test.config", logger)

	var sb strings.Builder
	writer.writeHostEntry(&sb, host)

	result := sb.String()
	require.Contains(t, result, "Host testhost")
	// Should not include HostName for user-defined commands
	require.NotContains(t, result, "HostName")
}

// extractHostBlock extracts the configuration block for a specific host
func extractHostBlock(config, hostName string) string {
	lines := strings.Split(config, "\n")
	var block strings.Builder
	inBlock := false

	for _, line := range lines {
		if strings.HasPrefix(line, "Host ") {
			if strings.Contains(line, hostName) {
				inBlock = true
				block.WriteString(line + "\n")
			} else if inBlock {
				// We've reached the next host block
				break
			}
		} else if inBlock {
			if strings.TrimSpace(line) == "" {
				// End of block
				break
			}
			block.WriteString(line + "\n")
		}
	}

	return block.String()
}
